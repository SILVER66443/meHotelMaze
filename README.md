# 关于项目的介绍
### 前言

##### 11月27号更新：

1：将整个模型全部模块化，封装成类。但碍于时间不够，原来的还没重新封装。

2：新做了撞墙功能，相对于上个版本，新版本添加了墙的概念，现在没办法穿墙了。

***

### 1：随机prim算法梗概
**废话**

《prim_self.py》随机prim算法，随后得到一个迷宫矩阵，这个矩阵由3位flag组成，分别是
    
    0：未访问路径.
    1：未访问墙.
    2：已访问后标记的路径，包括墙，墙在被打破后也属于可行进路径.
    3：已访问但不打破的墙.
最终的访问结果是没有-1的。算法缺陷：效率巨tm低，每个循环内最多添加2面墙，并且只打破1面墙，对于大规格的迷宫几乎无效。999*999的迷宫几乎就不能满足在短时间生成，并且对于大型多维迷宫几乎就是个几乎绝望的事情，虽然大部分迷宫的规格不大，但是在后面想到了一个突发情况

**算法流程：**

    1:初始化迷宫为田字格
    2：选择一个位置开始探索（本文称该格子为seeker）
    3：将seeker附近的墙添加到墙列表。
    4：从墙中随机移出一个
        5：处理该墙与重新定义seeker
    6：回到3（直到墙列表为空）
   
### 2：界面
关于界面和底层的数据交互方式的组成，这个问题其实是一个比较讨厌的事情，为什么这么说呢，因为到底组成迷宫的数据结构是什么，该如何设计，这个问题比较难解决。目前的想法是，底层用矩阵二值矩阵并且以此作为处理各种移动等事件，将底层的几计算结果返回，最后设计一组映射关系将底层的二值矩阵放大对应到界面去，这样一来就解决了撞墙问题。

    
### 3：想法

1：推到三维迷宫，形成迷宫中的迷宫，当前的迷宫中的迷宫也许对当前迷宫是无效的，但是对于其他维度的迷宫也许就是有效的，例如第一张地图的某个进入下一个地图的点，这个覆盖部分在第一张上是有效的，但是在进入第二张部分后变成闭合回路导致无法进入第三张地图，或许出发额外的收集机制。这样的设计早某种程度上还增加迷宫的非线性化趣味。

2：如何增强迷宫生成的路径访问效率，prim添加墙摧毁墙的效率是非常低的。

3：如何设计边缘计算，碰撞等事件的发生。

***

### 下一阶段的目标

1：考虑使用pymunk物理引擎来转换整个游戏模型。

2：如何设计新的数据结构。

