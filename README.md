# 关于项目的介绍
### 前言

##### 12月21号更新：

目前的问题是，迷宫的底层数据组织和管理还是不太到位，导致增强学习的部分无法很好的完成奖励机制的获取。所以要重新考虑下底层数据的组织方式，尤其是方法的设计，移动方法返回的数据个数及其类别都有待考虑，最主要的是，step_move等方法要同时能够在游戏模块简单易用，也要使得增强学习模块能够有更好的易用性，不然在设计增强学习的过程中，就会遇到巨恶心的麻烦，例如状态值无法合理更新。上述问题最主要的矛盾就是奖励机制的设定不太合适。

***

### 1：随机prim算法梗概
**废话**

《prim_self.py》随机prim算法，随后得到一个迷宫矩阵，这个矩阵由3位flag组成，分别是
    
    0：未访问路径.
    1：未访问墙.
    2：已访问后标记的路径，包括墙，墙在被打破后也属于可行进路径.
    3：已访问但不打破的墙.
最终的访问结果是没有-1的。算法缺陷：效率巨tm低，每个循环内最多添加2面墙，并且只打破1面墙，对于大规格的迷宫几乎无效。999*999的迷宫几乎就不能满足在短时间生成，并且对于大型多维迷宫几乎就是个几乎绝望的事情，虽然大部分迷宫的规格不大，但是在后面想到了一个突发情况.

**算法流程：**

    1：初始化迷宫为田字格
    2：选择一个位置开始探索（本文称该格子为seeker）
    3：将seeker附近的墙添加到墙列表。
    4：从墙中随机移出一个
    5：处理该墙与重新定义seeker
    6：回到3（直到墙列表为空）
   
### 2：界面
关于界面和底层的数据交互方式的组成，这个问题其实是一个比较讨厌的事情，为什么这么说呢，因为到底组成迷宫的数据结构是什么，该如何设计，这个问题比较难解决。目前的想法是，底层用矩阵二值矩阵并且以此作为处理各种移动等事件，将底层的几计算结果返回，最后设计一组映射关系将底层的二值矩阵放大对应到界面去，这样一来就解决了撞墙问题。

    
### 3：想法

1：推到三维迷宫，形成迷宫中的迷宫，当前的迷宫中的迷宫也许对当前迷宫是无效的，但是对于其他维度的迷宫也许就是有效的，例如第一张地图的某个进入下一个地图的点，这个覆盖部分在第一张上是有效的，但是在进入第二张部分后变成闭合回路导致无法进入第三张地图，或许出发额外的收集机制。这样的设计早某种程度上还增加迷宫的非线性化趣味。

2：如何增强迷宫生成的路径访问效率，prim添加墙摧毁墙的效率是非常低的。

3：如何设计边缘计算，碰撞等事件的发生。

***

### 下一阶段的目标

1：考虑使用pymunk物理引擎来转换整个游戏模型。

2：如何设计新的数据结构。

3：重铸游戏的底层奖励机制，尽量不要让各模块耦合。