# 关于项目的介绍

### 1:随机prim算法梗概
**废话**

《prim_self.py》随机prim算法，随后得到一个迷宫矩阵，这个矩阵由3位flag组成，分别是
    
    0：未访问路径.
    1：未访问墙.
    2：已访问后标记的路径，包括墙，墙在被打破后也属于可行进路径.
    3：已访问但不打破的墙.
最终的访问结果是没有-1的。算法缺陷：效率巨tm低，每个循环内最多添加2面墙，并且只打破1面墙，对于大规格的迷宫几乎无效。999*999的迷宫几乎就不能满足在短时间生成，并且对于大型多维迷宫几乎就是个几乎绝望的事情，虽然大部分迷宫的规格不大，但是在后面想到了一个突发情况

**算法流程：**

    1:初始化迷宫为田字格
    2：选择一个位置开始探索（本文称该格子为seeker）
    3：将seeker附近的墙添加到墙列表。
    4：从墙中随机移出一个
        5：处理该墙与重新定义seeker
    6：回到3（直到墙列表为空）
    
### 想法

1：推到三维迷宫，形成迷宫中的迷宫，当前的迷宫中的迷宫也许对当前迷宫是无效的，但是对于其他维度的迷宫也许就是有效的，例如第一张地图的某个进入下一个地图的点，这个覆盖部分在第一张上是有效的，但是在进入第二张部分后变成闭合回路导致无法进入第三张地图，或许出发额外的收集机制。这样的设计早某种程度上还增加迷宫的非线性化趣味。

2：如何增强迷宫生成的路径访问效率，prim添加墙摧毁墙的效率是非常低的。

